#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  
# ----------------------- COVERAGE-MERGR ---------------------------------
#
# Author:  Luke Shillabeer
# Version: 0.1.1
# Date:    13/02/2014
#
# Created in order to merge the values in all coverage files together
# as well as merge in the primers used for the regions specified within
# the coverage files.
#
# Thanks to Harriet Dashnow for her super.merge function.

#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
#-------------------- SET IMPORT LOCATIONS -------------------------------

### block_locations requires a tab-seperated-values file with columns;
### chromosome | block_start | block_end | forward_primer | reverse_primer
block_locations_path <- "/Users/lukeshillabeer/Documents/analysis-of-primers/data-from-collabs/745-plex"
block_locations_name <- "block_primer.tsv"

### coverage requires coverage files, generated by the ROVER software.
coverage_path <- "/Users/lukeshillabeer/Documents/analysis-of-primers/745-set/745-plex_Expt103_106/rover/coverage_files"
coverage_name <- "*.coverage"

#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
#-------------------- SETUP ANALYSIS TASKS -------------------------------

### Turns off/on the analysis section of the script: if off, smart_merge table 
### (with all coverage files and primers mapped) will still be generated.
do_analysis <- F
create_graphs <- F

### These are only relevent if the 'do_analysis' variable is set TRUE (T)

# Importing the GC-content data
fwd_gc_content_path <- "/Users/lukeshillabeer/Code/primer-lint/primerlint/output"
fwd_gc_content_name <- "fwd_primer_745.txt"

rev_gc_content_path <- "/Users/lukeshillabeer/Code/primer-lint/primerlint/output"
rev_gc_content_name <- "rev_primer_745.txt"

#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
#--------------------------- FUNCTIONS -----------------------------------

smart.merge <- function(x, y, key){
  # x and y are data frames with at least one column in common and sharing one column of unique keys
  # key is a string containing the column heading that is shared by both contains unique keys
  
  # Merge the two tables by the key column
  merged = merge(x, y, by=key, all=TRUE, suffixes = c(".x",".y"))
  
  # Get a list of all the columns that are shared between the two tables excluding the key column
  x.names = names(x)
  y.names = names(y)
  x.and.y = intersect(x.names, y.names)
  shared.cols = x.and.y[!(x.and.y %in% key)]
  #print(shared.cols)
  for (col in shared.cols) {
    col.x.name = paste(col,".x", sep = "")
    col.y.name = paste(col,".y", sep = "")
    #print(merged[col.x.name])
    col.xy = merge.cols(merged[,col.x.name], merged[,col.y.name])
    all.names = names(merged)
    merged = cbind(merged,col.xy)
    all.names = append(all.names,col)
    names(merged) = all.names
    merged = merged[!(all.names %in% c(col.x.name,col.y.name))]
}
  
  return(merged)
}
makedataframe <- function(coverage_files) {
  for (item in coverage_files) {
    temp_data = lapply(item, read.table, header=FALSE, sep='\t')
  }
  return(data.frame(temp_data))
}
mergebasewithcoverage <- function(base, coverage, coverage_name) {
  
  # create a unique key, then merge using that key
  coverage$key <- paste(coverage$chr, coverage$block_start)
  mbl <- merge(base, coverage, by="key", all=TRUE)
  
  # drop the columns that aren't needed
  col_drops <- c('block_start.y', "block_end.y", "chr")
  mbl = mbl[,!(names(mbl) %in% col_drops)]
  
  # rename the num_pairs column to the .coverage file it was from
  # and remove any row with NA in primer columns
  names(mbl)[names(mbl) == "num_pairs"] <- coverage_name
  names(mbl)[names(mbl) == "block_start.x"] <- "block_start"
  names(mbl)[names(mbl) == "block_end.x"] <- "block_end"
  mbl = mbl[complete.cases(mbl[,6:8]),]
  
  return(mbl)
}

#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
#--------------------------- DATA SETUP ----------------------------------

# create the base data-frame which has the primers and gene-names
base_file = list.files(full.names = T, path = block_locations_path, pattern = block_locations_name)
base_df = makedataframe(coverage_files = base_file)

# name the columns, create a key, move the key to the first column
colnames(base_df) <- c("chro", "block_start", "block_end", "fwd_primer", "rev_primer")
base_df$key <- paste(base_df$chro, base_df$block_end)
base_df = base_df[,c("key", "chro", "block_start", "block_end", "fwd_primer", "rev_primer")]

# import the coverage files
coverage_files <- list.files(full.names = T, path = coverage_path, pattern = coverage_name)
list_of_data <- lapply(coverage_files, read.table, header=TRUE, sep="\t")

# create the intial smart-merge data-frame
smart_merge <- as.data.frame(list_of_data[1])
smart_merge$key <- paste(smart_merge$chr,smart_merge$block_end)
smart_merge <- smart_merge[,c(5, 1, 2, 3, 4)]
names(smart_merge)[5] <- "num_pairs_1"

for (i in 2:length(list_of_data)){
  tempdf <- data.frame(list_of_data[i])
  tempdf$key <- paste(tempdf$chr, tempdf$block_end)
  tempdf <- tempdf[,c("key","num_pairs")]
  names(tempdf)[2] <- paste("num_pairs", i, sep="_")
  smart_merge <- smart.merge(smart_merge, tempdf, "key")
}

# merge in some extra data (exon_id and primers)
base_df_merge <- base_df[,c("key","fwd_primer","rev_primer")]
smart_merge <- smart.merge(smart_merge,base_df_merge,"key")

if (do_analysis == T) {
  # import the GC-content data
  fwd_gc_content_file <- list.files(full.names = T, path = fwd_gc_content_path, pattern = fwd_gc_content_name)
  fwd_gc_content <- as.data.frame(lapply(fwd_gc_content_file, read.table, sep="\t", header=T))
  
  rev_gc_content_file <- list.files(full.names = T, path = rev_gc_content_path, pattern = rev_gc_content_name)
  rev_gc_content <- as.data.frame(lapply(rev_gc_content_file, read.table, sep="\t", header=T))
  
  smart_merge <- merge(smart_merge, fwd_gc_content, "key")
  smart_merge <- merge(smart_merge, rev_gc_content, "key")
}

#-------------------------------------------------------------------------
#  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
# /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  / 
#-------------------------- ANALYSIS PHASE -------------------------------

### Pre-analysis; clean up workspace by removing extraneous crap
# perform some cleanup of useless data-frames before starting analysis
rm(base_df, base_df_merge, tempdf, fwd_gc_content, rev_gc_content, list_of_data)

# do the analysis on datasets
if (do_analysis == T) {
  # create a data-frame for fwd-gc, rev-gc and absolute count of reads
  unique_fwd_gc <- unique(x=smart_merge$fwd_gc)
  unique_rev_gc <- unique(x=smart_merge$rev_gc)
  
  cg_with_reads <- data.frame(matrix(nrow(smart_merge), ncol=3))
  names(cg_with_reads) = c("fwd_gc","rev_gc","reads")
  
  row_to_insert <- c(smart_merge[1,17],smart_merge[1,18],sum(smart_merge[1,6:10],na.rm=T))
  
  for (j in 1:nrow(smart_merge)) {
    row_to_insert <- c(smart_merge[j,17],smart_merge[j,18],sum(smart_merge[j,6:10],na.rm=T))
    cg_with_reads[j,] <- row_to_insert
  }
  
  cg_with_reads_matrix <- data.matrix(cg_with_reads)
  cg_matrix_for_image <- matrix(nrow=100, ncol=100)
  
  # get the averaging working second
  for (k in 1:nrow(cg_with_reads_matrix)) {
    tempv <- cg_with_reads_matrix[k,]
    cg_matrix_for_image[tempv[1],tempv[2]] <- tempv[3]
  }
}

# Create some plots/graphs
if (create_graphs == T) {
  levelplot(cg_matrix_for_image, allow.multiple=T, col.regions=topo.colors(100))
  #pheatmap(cg_matrix_for_image, cluster_rows=T, cluster_cols=T, show_rownames=T, show_colnames=T)
  #cloud(cg_matrix_for_image)
}
