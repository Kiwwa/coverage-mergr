# ----------------------- COVERAGE-MERGR -------------------------------
#
# Author:  Luke Shillabeer
# Version: 0.1
# Date:    13/02/2014
#
# Created in order to merge the values in all coverage files together
# as well as merge in the primers used for the regions specified within
# the coverage files.
#
# Thanks to Harriet Dashnow for her super.merge function.

#-------------------- SET IMPORT LOCATIONS -------------------------------

### block_locations requires a tab-seperated-values file with columns;
### chromosome | block_start | block_end | forward_primer | reverse_primer

block_locations_path <- "/Users/lukeshillabeer/Documents/analysis-of-primers/data-from-collabs/745-plex"
block_locations_name <- "block_primer.tsv"

### coverage requires coverage files, generated by the ROVER software.
coverage_path <- "/Users/lukeshillabeer/Documents/analysis-of-primers/745-set/745-plex_Expt103_106/rover/coverage_files"
coverage_name <- "*.coverage"

# GC content not currently in use
gc_content_path <- ""
gc_content_name <- ""
#-------------------------------------------------------------------------

smart.merge <- function(x, y, key){
  # x and y are data frames with at least one column in common and sharing one column of unique keys
  # key is a string containing the column heading that is shared by both contains unique keys
  
  # Merge the two tables by the key column
  merged = merge(x, y, by=key, all=TRUE, suffixes = c(".x",".y"))
  
  # Get a list of all the columns that are shared between the two tables excluding the key column
  x.names = names(x)
  y.names = names(y)
  x.and.y = intersect(x.names, y.names)
  shared.cols = x.and.y[!(x.and.y %in% key)]
  #print(shared.cols)
  for (col in shared.cols) {
    col.x.name = paste(col,".x", sep = "")
    col.y.name = paste(col,".y", sep = "")
    #print(merged[col.x.name])
    col.xy = merge.cols(merged[,col.x.name], merged[,col.y.name])
    all.names = names(merged)
    merged = cbind(merged,col.xy)
    all.names = append(all.names,col)
    names(merged) = all.names
    merged = merged[!(all.names %in% c(col.x.name,col.y.name))]
  }
  
  return(merged)
}
makedataframe <- function(coverage_files) {
  for (item in coverage_files) {
    temp_data = lapply(item, read.table, header=FALSE, sep='\t')
  }
  return(data.frame(temp_data))
}
mergebasewithcoverage <- function(base, coverage, coverage_name) {
  
  # create a unique key, then merge using that key
  coverage$key <- paste(coverage$chr, coverage$block_start)
  mbl <- merge(base, coverage, by="key", all=TRUE)
  
  # drop the columns that aren't needed
  col_drops <- c('block_start.y', "block_end.y", "chr")
  mbl = mbl[,!(names(mbl) %in% col_drops)]
  
  # rename the num_pairs column to the .coverage file it was from
  # and remove any row with NA in primer columns
  names(mbl)[names(mbl) == "num_pairs"] <- coverage_name
  names(mbl)[names(mbl) == "block_start.x"] <- "block_start"
  names(mbl)[names(mbl) == "block_end.x"] <- "block_end"
  mbl = mbl[complete.cases(mbl[,6:8]),]
  
  return(mbl)
}

# create the base data-frame which has the primers and gene-names
base_file = list.files(full.names = T, path = block_locations_path, pattern = block_locations_name)
base_df = makedataframe(coverage_files = base_file)

# name the columns, create a key, move the key to the first column
colnames(base_df) <- c("chro", "block_start", "block_end", "fwd_primer", "rev_primer")
base_df$key <- paste(base_df$chro, base_df$block_end)
base_df = base_df[,c("key", "chro", "block_start", "block_end", "fwd_primer", "rev_primer")]

# import the coverage files
coverage_files <- list.files(full.names = T, path = coverage_path, pattern = coverage_name)
list_of_data <- lapply(coverage_files, read.table, header=TRUE, sep="\t")

# create the intial smart-merge data-frame
smart_merge <- as.data.frame(list_of_data[1])
smart_merge$key <- paste(smart_merge$chr,smart_merge$block_end)
smart_merge <- smart_merge[,c(5, 1, 2, 3, 4)]
names(smart_merge)[5] <- "num_pairs_1"

for (i in 2:10){
  tempdf <- data.frame(list_of_data[i])
  tempdf$key <- paste(tempdf$chr, tempdf$block_end)
  tempdf <- tempdf[,c("key","num_pairs")]
  names(tempdf)[2] <- paste("num_pairs", i, sep="_")
  smart_merge <- smart.merge(smart_merge, tempdf, "key")
}

# merge in some extra data (exon_id and primers)
base_df_merge <- base_df[,c("key","fwd_primer","rev_primer")]
smart_merge <- smart.merge(smart_merge,base_df_merge,"key")


# import the GC-content data
gc_content_file <- list.files(full.names = T, path = "/Users/lukeshillabeer/Code/primer-lint/primerlint/output", pattern = 'output.txt')
gc_content <- as.data.frame(lapply(gc_content_file, read.table, sep="\t"))
names(gc_content)[1] <- "fwd_primer"
names(gc_content)[2] <- "fwd_gc"

# merge in the foward GC-content data
smart_merge_new <- merge(x=smart_merge, y=gc_content, by="fwd_primer")

# renames for reverse GC-content then merge it into a new data-frame
names(gc_content)[1] <- "rev_primer"
names(gc_content)[2] <- "rev_gc"
smart_merge_with_gc <- merge(x=smart_merge_new, y=gc_content, by="rev_primer")

# perform some cleanup of useless data-frames before starting analysis
rm(base_df, base_df_merge, smart_merge_new, tempdf)

# create a data-frame for fwd-gc, rev-gc and absolute count of reads
unique_fwd_gc <- unique(x=smart_merge_with_gc$fwd_gc)
unique_rev_gc <- unique(x=smart_merge_with_gc$rev_gc)
